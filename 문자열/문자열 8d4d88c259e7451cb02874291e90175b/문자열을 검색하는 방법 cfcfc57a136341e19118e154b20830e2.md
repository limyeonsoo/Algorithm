# 문자열을 검색하는 방법.

# 문자열 검색 방법

## 1. 가장 단순한 문자열 검색

T배열의 문자와 P 배열의 문자를 하나씩 비교하는 방법.

1.

N :  1 2 3 4 5 6 7 8
M :  3 4 5 6
⇒  X X X X

2.

N : 1 2 3 4 5 6 7 8
M :    3 4 5 6
⇒    X X X X

3.

N : 1  2  3  4  5  6  7  8
M :         3  4  5  6
⇒         O O O O 

### 시간복잡도

N개의 문자열과 M개의 문자열을 모두 비교하므로
**O(NM)**

## 2. KMP를 이용한 문자열 검색

### KMP

### 시간복잡도

O (N+M)

### 방식

1. 접두사를 참고하여 문자열이 같은지 확인한다.
2. 다르다면 Fail함수를 통해 접미사와 일치하는 곳으로 이동하여 확인한다.

### 접두사(suffix) & 접미사(prefix)

 N이 **1 2 3 4 5** 일 때,

- 접두사

    1
    12
    123
    1234
    12345

- 접미사
       5
     45
    345
  2345
12345

### Fail 배열

다른 문자열이 있을 경우 이동해야할 곳을 알려주는 배열

```cpp
int fail[MAX] = {0};
for(int i=1, j=0; i<M; i++){
    while(j > 0 && W[i] != W[j]) j = fail[j-1];
    if(W[i] == W[j]) fail[i] = ++j;
}
```

## 3. Hash를 이용하는 방법

단어를 Hash에 넣어 find를 한다.

이때, unordered_set / unordered_map 이면 O(1)로 find가능.

```cpp
if (set.find(sub) != set.end())
```

## 4. Trie를 이용하는 방법

문자열 1개 씩 node에 저장하여 탐색 할 수 있는 방법.

시간복잡도는 문자열의 길이 만큼이지만

공간복잡도는 복잡하다.
  숫자 :  1노드당 10개의 0~9 노드를 가짐.
  영어 :  1노드당 26개의 a_z 노드를 가짐.

![%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%20cfcfc57a136341e19118e154b20830e2/Trie.png](%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%20cfcfc57a136341e19118e154b20830e2/Trie.png)